========================================================
                    PYLON CHEAT SHEET
========================================================

This cheat sheet provides a quick-reference guide to the core concepts
of the Pylon library in Flutter. It includes examples of how to use
immutable and mutable Pylons, future- and stream-based Pylons, as well
as references to context extension methods that make working with data
easy. Detailed code examples are appended at the bottom.

--------------------------------------------------------
1. WHAT IS PYLON?
--------------------------------------------------------
- A Flutter library for sharing data throughout the widget tree.
- Operates similarly to an InheritedWidget, but provides a simpler,
  more flexible API.
- Offers:
  • Immutable data provision (Pylon<T>)
  • Mutable data (MutablePylon<T>)
  • Built-in helpers for Futures & Streams (PylonFuture, PylonStream)
  • URL syncing for web apps (PylonPort<T>)
  • Navigation helpers (Pylon.push, etc.)
  • Global state management (Conduit<T>)

--------------------------------------------------------
2. CORE WIDGETS
--------------------------------------------------------
(1) Pylon<T>
  • Provides a value of type T to descendant widgets.
  • Constructors: Pylon({Key? key, required T value, PylonBuilder? builder, bool local = false}), Pylon.data({Key? key, required T value, bool local = false}), Pylon.withChild({Key? key, required T value, Widget? child, bool local = false}).
  • local: If true, won't transfer across navigation.
  • Retrieve it in child widgets via:
      context.pylon<T>() or context.pylonOr<T>() or context.hasPylon<T>().

(2) MutablePylon<T>
  • Maintains a mutable value of type T.
  • Descendants can update it by:
      context.setPylon<T>(newValue)
      context.modPylon<T>((oldValue) => newValue)
  • If rebuildChildren = true, descendant widgets rebuild on updates.

(3) PylonFuture<T>
  • Wraps a FutureBuilder and automatically provides the completed value.
  • Accepts:
      future: Future<T>
      initialData: T?
      builder: (context) => Widget
      loading/error states

(4) PylonStream<T>
  • Wraps a StreamBuilder. As the stream emits values, they're exposed
    to descendants via Pylon.

(5) PylonPort<T extends PylonCodec>
  • Designed for web usage.
  • Syncs a typed value with the browser’s URL (query params).
  • Requires registering a custom codec that implements PylonCodec.
  • Tip: Use registerPylonCodec<T>(codec) somewhere in your main method to register codecs globally.

(6) PylonCluster
  • Combines multiple Pylon or MutablePylon widgets into one.
  • Syntax: PylonCluster(pylons: [Pylon<T1>(...), Pylon<T2>(...)], builder: (context) => Widget)
  • Use Case: Simplifies providing multiple values at once.

(7) PylonRemove<T>
  • Removes a Pylon<T> value for its subtree, making context.pylon<T>() throw or pylonOr<T>() return null.
  • Works for nullable types (e.g., Pylon<ThemeData?>).
  • Syntax: PylonRemove<T>(builder: (context) => Widget)
  • Use Case: Overrides or resets a Pylon value in specific branches.

(8) Conduit<T>
A global state container for managing app-wide data or events. Unlike Pylon or MutablePylon, which rely on the widget tree, Conduit stores data in static BehaviorSubject instances. It’s helpful if you need truly global, widget-independent state. Conduit is also a widget: Conduit({Key? key, required Widget builder(BuildContext context, T? value), T? defaultData}).
Common static methods include:
	•	Conduit.push<T>(value) Publishes (pushes) a new value into the global Conduit<T>.
	•	Conduit.pull<T>() Fetches the most recent value from Conduit<T> (returns an error if no Conduit<T> has been established yet).
	•	Conduit.pullOr<T>(default) Fetches the most recent value or default.
	•	Conduit.mod<T>((oldValue) => newValue) Functionally updates the value in Conduit<T> by applying a transformation to the old value.
	•	Conduit.modOr<T>((oldValue?) => newValue) Modifies, handling null.
	•	Conduit.stream<T>() Returns a Stream<T> that emits updates whenever Conduit.push or Conduit.mod changes the data.
	•	Conduit.subject<T>() Returns the BehaviorSubject<T>.
	•	Conduit.destroy<T>() Destroys the Conduit<T> instance and clears its stored data.
	•	Conduit.destroyAllConduits() Destroys all existing Conduit streams in one call.
	EG:
// Initialize or update user data globally:
Conduit.push<User>(User(name: 'Alice', age: 30));

// Access the current user anywhere:
final user = Conduit.pull<User>();
print(user.name); // "Alice"

// Listen for changes as a stream:
final userStream = Conduit.stream<User>();
userStream.listen((updatedUser) => print(updatedUser.name));

// Modify the user data:
Conduit.mod<User>((oldUser) => oldUser.copyWith(name: '${oldUser.name} [updated]'));

--------------------------------------------------------
3. NAVIGATION HELPERS
--------------------------------------------------------
- Pylon.push<T>(context, child, {settings, type = PylonRouteType.material, route}): Pushes a new route, preserving Pylon values.
- Pylon.pushReplacement<T, TO>(context, child, {settings, type = PylonRouteType.material, route}): Replaces the current route.
- Pylon.pushAndRemoveUntil<T>(context, child, {settings, type = PylonRouteType.material, route, required predicate}): Pushes a route and removes all previous routes until the predicate is met.
- Pylon.materialPageRoute<T>(context, builder, {settings}): Creates MaterialPageRoute with Pylons.
- Pylon.cupertinoPageRoute<T>(context, builder, {settings}): Creates CupertinoPageRoute with Pylons.
- Use Case: Ensures Pylon data persists during navigation. Use local=true to prevent transfer.

--------------------------------------------------------
4. CONTEXT EXTENSION METHODS
--------------------------------------------------------
Use these inside any descendant widget:

  • context.pylon<T>()
    => Returns the nearest Pylon<T> value. Throws if not found.

  • context.pylonOr<T>()
    => Returns the nearest Pylon<T> value or null if not found.

  • context.hasPylon<T>()
    => Returns true if Pylon<T> exists.

  • context.setPylon<T>(newValue)
    => Updates the value of the nearest MutablePylon<T>.

  • context.modPylon<T>((oldVal) => newVal)
    => Functional update on the nearest MutablePylon<T>.

  • context.streamPylon<T>()
    => Returns the update stream from a MutablePylon<T>.

  • context.watchPylon<T>((val) => Widget)
    => Builds a widget that reacts to changes in a MutablePylon<T>.

--------------------------------------------------------
5. HELPER EXTENSIONS
--------------------------------------------------------
- stream.asPylon(): Converts a Stream<T> into a PylonStream<T>.
- iterable.withPylons(): Wraps an iterable with Pylon providers for each item.
- Use Case: Simplifies integrating streams or lists with Pylon.

--------------------------------------------------------
6. QUICK USAGE FLOW
--------------------------------------------------------
    Pylon<T>              -> "Provide data"
    MutablePylon<T>       -> "Provide mutable data"
    PylonFuture<T>        -> "Provide data from an async future"
    PylonStream<T>        -> "Provide data from a stream"
    PylonPort<T>          -> "Sync data with URL (web-specific)"
    PylonCluster          -> "Combine multiple Pylons"
    PylonRemove<T>        -> "Remove a Pylon value for subtree"
    Conduit<T>            -> "Global state management"

--------------------------------------------------------
7. EXAMPLES
--------------------------------------------------------
Below are example snippets showcasing usage of Pylon.

-------------------------
EXAMPLE 1: Immutable Pylon
-------------------------

import ‘package:flutter/material.dart’;
import ‘package:pylon/pylon.dart’;

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
// Provide a User object to the widget tree
    return Pylon(
      value: User(name: ‘Alice’, age: 30),
      builder: (context) {
        return MaterialApp(
          home: HomePage(),
        );
      },
    );
  }
}

class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
// Retrieve the User from the Pylon
    final user = context.pylon<User>();
    return Scaffold(
      body: Center(
        child: Text('Hello, ${user.name}!'),
      ),
    );
  }
}

class User {
  final String name;
  final int age;
  User({required this.name, required this.age});
}

-------------------------
EXAMPLE 2: MutablePylon with Increment
-------------------------

class CounterApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MutablePylon(
      value: 0, // initial count
      rebuildChildren: true,
      builder: (context) {
        return MaterialApp(
          home: CounterPage(),
        );
      },
    );
  }
}

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final count = context.pylon<int>(); // read the current count
    return Scaffold(
      appBar: AppBar(title: Text('Counter: $count')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // increment the count
            context.modPylon<int>((oldVal) => oldVal + 1);
          },
          child: Text('Increment'),
        ),
      ),
    );
  }
}

-------------------------
EXAMPLE 3: Combining PylonFuture and MutablePylon
-------------------------

class MyCompleteApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: PylonFuture(
        future: fetchUserFromApi(),
        loading: CircularProgressIndicator(),
        error: Text(‘Error fetching user’),
        builder: (context) {
// Once future completes, we have a Pylon
          final user = context.pylon<User>();
// Make it mutable for potential updates
          return MutablePylon<User>(
            value: user,
            rebuildChildren: true,
            builder: (context) => ProfilePage(),
          );
        },
      ),
    );
  }
}

class ProfilePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final user = context.pylon<User>();
    return Scaffold(
      appBar: AppBar(title: Text(user.name)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            context.modPylon<User>(
                    (oldUser) => oldUser.copyWith(name: ‘${oldUser.name} [updated]’)
            );
          },
          child: Text(‘Update Name’),
        ),
      ),
    );
  }
}

class User {
  final String name;
  final int age;
  User({required this.name, required this.age});

  User copyWith({String? name, int? age}) =>
      User(name: name ?? this.name, age: age ?? this.age);
}

Future<User> fetchUserFromApi() async {
  await Future.delayed(Duration(seconds: 2));
  return User(name: ‘Alice’, age: 30);
}

-------------------------
EXAMPLE 4: Navigation with Pylon
-------------------------

class NavExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Pylon<int>(
      value: 42,
      builder: (context) => Scaffold(
        body: Center(
          child: ElevatedButton(
            onPressed: () => Pylon.push(context, SecondPage()),
            child: Text('Go to Second Page'),
          ),
        ),
      },
    );
  }
}

class SecondPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final value = context.pylon<int>();
    return Scaffold(
      appBar: AppBar(title: Text('Second Page')),
      body: Center(child: Text('Value from Pylon: $value')),
    );
  }
}

--------------------------------------------------------
END OF CHEAT SHEET
--------------------------------------------------------